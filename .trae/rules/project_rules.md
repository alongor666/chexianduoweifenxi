
# AI 协作导航 

本文档是与 AI 协作者 高效协作的核心指南，旨在通过提供高级原则、关键入口和统一的知识库链接，确保开发过程的连贯性与高质量。

## 使用Chrome DevTools 插件直接看问题

## 核心原则：五条黄金法则

1. **优先修改，而非新建**：尽可能在现有代码和文件结构上进行迭代，避免不必要的文件增删。
2. **小步快跑，持续验证**：每次只做一个小功能或修复，完成后立即在本地运行 `pnpm dev` 进行验证，确保每一步都稳固可靠。
3. **文档同步，保持鲜活**：代码的任何变更，尤其是数据结构、核心逻辑或开发流程的调整，都必须同步更新到 `开发文档/` 目录下的相关文档中。
4. **保持代码质量**：在所有修改中，保持代码的质量和可维护性。避免引入新的错误或问题。
5. **中文沟通**：使用中文与用户沟通，且在所有文档中保持中文。代码中所有的注释等都必须使用中文。

## 最小化工作流

`阅读代码` -> `提议修改` -> `执行修改` -> `本地验证` -> `更新文档`

1. **阅读代码**：在开始修改之前，先彻底理解代码的功能、上下文和潜在影响。
2. **提议修改**：根据理解，提出具体的修改建议，包括代码变更、架构调整或文档更新。
3. **执行修改**：将 AI 建议的修改直接应用到代码中，确保符合项目的编码规范和最佳实践。
4. **本地验证**：在本地运行项目，验证修改后的功能是否按预期工作，没有引入新的错误或问题。
5. **更新文档**：根据修改内容，同步更新 `开发文档/` 目录下的相关文档，确保文档与代码保持一致。

## 关键入口点

- **数据模型与验证规则**:

  - `prisma/schema.prisma`: 数据库表结构的唯一真实来源。
  - `src/lib/schema/insurance.ts`: Zod 定义的数据验证 schema。
  - `开发文档/03_technical_design/data_architecture.md`: 数据架构、字段定义和CSV导入规范的详细文档。
- **核心业务逻辑**:

  - `src/app/api/kpi/route.ts`: 后端 KPI 计算的核心 API 端点。
  - `开发文档/03_technical_design/core_calculations.md`: 所有核心KPI的计算公式与业务逻辑。
- **前端页面与组件**:

  - `src/app/page.tsx`: 应用主页面，包含布局和核心组件集成。
  - `src/components/data-table.tsx`: 核心数据展示表格。
- **技术栈与环境**:

  - `开发文档/03_technical_design/tech_stack.md`: 包含项目技术选型、关键库和本地开发环境设置的完整指南。

## 知识库导航

- **📖 知识库索引**: `开发文档/KNOWLEDGE_INDEX.md` - 自动生成的完整文档导航
  - 📊 知识库概览统计（功能模块、技术决策、技术设计、重构文档）
  - 🔥 最近30天更新的文档快速访问
  - 🎯 13个功能模块详细索引（按优先级组织）
  - 🏗️ 3个技术决策记录（ADR）
  - ⚙️ 10个技术设计文档
  - 🔧 8个重构文档
  - 🏷️ **NEW: 标签索引** - 按标签快速查找相关文档
  - 🔗 **NEW: 文档依赖关系图** - 显示文档之间的引用关系和核心文档
  - **更新命令**: `pnpm docs:index` - 文档变更后运行此命令更新索引

## 文档管理工具

### 📚 知识库索引生成

```bash
# 扫描开发文档并生成索引（包含标签索引和依赖关系图）
pnpm docs:index
```

### 🗂️ 归档清理工具

```bash
# 分析归档文档（仅报告）
pnpm docs:archive:analyze

# 交互式清理归档
pnpm docs:archive:clean

# 自动清理预览（dry-run）
pnpm docs:archive:auto-clean
```

### 🤖 CI/CD 集成

- **检查索引**: PR 创建时自动检查文档索引是否最新
- **自动更新**: PR 中文档变更时自动更新索引并提交

## 文档约束

- **禁止直接修改本文件** (`AGENTS.md`, `CLAUDE.md`, `GEMINI.md`)。所有项目相关的知识、设计和流程都应归档至 `开发文档/` 目录中。这些协作导航文件只作为高级指引和链接入口。
- **将 `开发文档/` 视为活文档**，与代码和功能保持同步更新。
- **使用标签**: 在文档 frontmatter 中添加 `tags: [tag1, tag2]` 或在内容中使用 `#标签` 来提高文档可发现性。
- **维护引用**: 文档间使用相对路径链接，工具会自动分析依赖关系。

---

## 代码质量修复原则

### 1. 变量声明与使用一致性原则

- **规则**：变量/函数在声明处的名称必须与使用处完全一致
- **反例**：声明 `const _data = xxx`，使用 `data.map()`
- **正例**：声明 `const data = xxx`，使用 `data.map()`

### 2. 禁止规避式修复原则

- **规则**：不得为通过某项检查而破坏代码真实语义
- **反例**：为消除 `no-unused-vars` 而给实际使用的变量加 `_` 前缀
- **正例**：检查变量是否真的未使用，未使用则删除，使用了则保留原名

### 3. 下划线前缀使用规范

- **唯一合法场景**：变量在声明后确实完全未被使用
- **示例**：`const _unusedParam = param`（该变量后续无任何引用）
- **ES6 解构场景**：`const { used, unused: _unused } = obj`

### 4. 全链路验证原则

- **任何修复必须按顺序通过**：
  ```bash
  pnpm lint          # 第一关
  pnpm tsc --noEmit  # 第二关
  pnpm build         # 第三关
  ```
- 单项通过 ≠ 修复完成

### 5. 修复前溯源原则

- 遇到 lint 报错时的正确流程：
  a. 阅读完整错误信息  
  b. 定位到具体代码行  
  c. 理解报错原因  
  d. 判断变量是否真的未使用  
  e. 根据判断决定修复方式（删除 or 保留）
- 禁止：看到 `no-unused-vars` 就机械地加 `_` 前缀
